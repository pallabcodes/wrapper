/**
 * Auth Service
 * 
 * Business logic for authentication operations
 */

import { v4 as uuidv4 } from 'uuid'
import type { FastifyRequest } from 'fastify'
import type { 
  TokenPair, 
  UserState 
} from './types.js'
import { registerUser, loginUser } from './aggregates/index.js'
import type { AuthResponse } from './controller-schemas.js'

// ============================================================================
// AUTH SERVICE
// ============================================================================

export class AuthService {
  
  private handleDomainError(error: any): string {
    switch (error.type) {
      case 'ValidationError':
        return error.message || 'Validation error'
      case 'BusinessRuleError':
        return error.message || 'Business rule violation'
      case 'NotFoundError':
        return 'Resource not found'
      case 'ConflictError':
        return error.message || 'Conflict occurred'
      case 'AuthorizationError':
        return 'Unauthorized access'
      case 'InfrastructureError':
        return 'Infrastructure error'
      default:
        return error.message || 'Unknown error'
    }
  }
  
  /**
   * Register a new user
   */
  async registerUser(
    email: string,
    password: string,
    firstName?: string,
    lastName?: string,
    marketingConsent = false,
    registrationIp?: string
  ): Promise<AuthResponse> {
    const command = {
      id: this.generateUserId(),
      email,
      password,
      profile: {
        firstName,
        lastName
      },
      marketingConsent,
      ...(registrationIp && { registrationIp })
    }

    const result = await registerUser(command)

    if (result.type === 'error') {
      throw new Error(this.handleDomainError(result.error))
    }

    const aggregate = result.value
    return {
      user: {
        id: aggregate.state.id,
        email: aggregate.state.email,
        roles: aggregate.state.roles,
        status: aggregate.state.status,
        emailVerified: aggregate.state.emailVerified
      },
      tokens: {
        accessToken: 'temp-token', // This would be generated by the aggregate
        refreshToken: 'temp-refresh',
        expiresIn: 900,
        tokenType: 'Bearer' as const
      }
    }
  }

  /**
   * Login user
   */
  async loginUser(
    email: string,
    password: string,
    rememberMe = false,
    ipAddress?: string,
    userAgent?: string
  ): Promise<AuthResponse> {
    // This would typically fetch the user from the repository first
    // For now, we'll create a mock user state
    const mockUserState: UserState = {
      id: this.generateUserId(),
      email,
      passwordHash: 'hashed-password',
      roles: ['customer'],
      permissions: [],
      profile: {},
      status: 'active',
      addresses: [],
      sessions: [],
      securitySettings: {
        twoFactorEnabled: false,
        loginNotifications: true,
        sessionTimeout: 1440,
        allowMultipleSessions: true,
        ipWhitelist: [],
        passwordExpiryDays: 90
      },
      emailVerified: true,
      phoneVerified: false,
      loginAttempts: 0,
      marketingConsent: false,
      createdAt: new Date(),
      updatedAt: new Date()
    }

    const command = {
      email,
      password,
      sessionId: uuidv4(),
      ...(ipAddress && { ipAddress }),
      ...(userAgent && { userAgent }),
      rememberMe
    }

    const result = await loginUser({ id: mockUserState.id, state: mockUserState, version: 1, events: [] }, command)

    if (result.type === 'error') {
      throw new Error(this.handleDomainError(result.error))
    }

    const { user, tokens } = result.value
    return {
      user: {
        id: user.state.id,
        email: user.state.email,
        roles: user.state.roles,
        status: user.state.status,
        emailVerified: user.state.emailVerified
      },
      tokens: {
        ...tokens,
        tokenType: 'Bearer' as const
      }
    }
  }

  /**
   * Generate a unique user ID
   */
  private generateUserId(): string {
    return uuidv4()
  }

  /**
   * Extract client IP from request
   */
  extractClientIP(request: FastifyRequest): string | undefined {
    return request.ip || 
           request.headers['x-forwarded-for'] as string || 
           request.headers['x-real-ip'] as string
  }
}
